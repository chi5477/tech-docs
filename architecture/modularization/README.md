# 模組化與分層原則（聚焦「功能模組化」）

> 本文件刻意站在「功能模組化」視角，先說清楚：功能模組化是什麼、它和「架構」的差異是什麼、若只有模組化沒有架構會遇到哪些痛點，最後給出最小可行的架構守則，協助團隊在不大改工程的前提下穩住品質與可維護性。文件採 UTF-8（無 BOM），對使用者溝通以繁體中文為準。

---

## 功能模組化是什麼？
- 定義：以「功能/業務能力」為單位切分程式碼與目錄，例如 `modules/orders`、`modules/billing`。
- 目標：提高內聚、降低跨檔案/跨資料夾追蹤的心智負擔，讓功能就近維護。
- 典型做法：每個功能自帶 controller/service/repository 等檔案，對外以函式或 API 暴露能力。

你很可能已經在做功能模組化，但這還不等於「有架構」。

---

## 功能模組化 vs 架構（差異）
- 範疇不同：
  - 功能模組化關注「怎麼把功能分門別類」；
  - 架構關注「模組之間可不可以互相依賴、依賴方向、如何替換 I/O、如何測試」。
- 邊界與依賴：
  - 功能模組化多半只有目錄與檔案分組；
  - 架構會定義邊界（Ports/Interfaces）與依賴規則（只向內、實作在外層）。
- 橫切關注處理：
  - 功能模組化常直接在各模組內部各自處理 SQL/HTTP/快取；
  - 架構會抽象 I/O（如 Repository、Gateway、Bus）並集中於 Adapters/Infrastructure。
- 可測性與替換性：
  - 只有模組化時，測試容易依賴真實 DB 或第三方；
  - 有架構時，核心依賴介面，測試用替身（mocks/fakes）輕鬆替換。

一句話：模組化幫你整理東西；架構幫你約束東西「如何互動」。兩者互補，不是擇一。

---

## 只有模組化、沒有架構的常見問題
- 牽一髮而動全身：
  - 不同模組都自行撰寫 SQL 或 HTTP 邏輯，當資料庫 schema、查詢策略或錯誤處理要調整時，需要到每個模組逐一修改。
- 可讀性下降、不可預測：
  - 無法確定某功能最終是怎麼被實作的（每個模組的做法都不一樣），閱讀成本高，缺陷定位困難。
- 重複實作與邏輯飄移：
  - 類似功能在每個模組各自重寫，時間久了行為與邊角條件不一致，導致不可預期的行為差異。
- 測試脆弱：
  - 單元測試不得不打到真實 DB/外部 API；當外部不穩定或資料不一致時，測試紅綠燈反覆。
- 隱性耦合擴散：
  - 透過共享資料表/實體、複製貼上的 util，形成灰箱耦合，影響邊界清晰度。

具體案例（SQL 未封裝）：
- 現況：`orders`、`billing`、`inventory` 三個模組都各自寫 SQL 查詢訂單與更新狀態。
- 結果：任一 SQL 調整（索引提示、欄位更名、JOIN 優化）都要同步改三處；若只改兩處會產生隱藏缺陷。
- 影響：
  - 變更成本高與風險高；
  - 無法建立一致的錯誤處理與重試策略；
  - 導致「我不知道這功能到底哪裡改過、誰在用」的閱讀與維運痛苦。

---

## 最小可行「架構守則」（在功能模組化之上）
- 抽象 I/O：
  - 將資料存取、訊息傳遞、第三方 API 定義為介面（Ports/Interfaces）。
  - 在模組內依賴介面，不依賴具體實作；實作放在 `adapters` 或 `infrastructure`。
- 統一資料存取：
  - 以 Repository/Gateway 封裝 SQL/HTTP/快取；跨模組共用時，統一放在 `shared` 或各自 context 的 adapter。
- 組合根（Composition Root）：
  - 在應用啟動處（如 `app/di/`）一次性完成介面→實作的綁定；測試環境可替換為測試實作。
- 合約與版本：
  - 對 Port/事件定義契約與版本；使用合約測試保障 Adapter 實作一致性。
- 命名與邊界：
  - 模組對外只暴露公開 API（介面），避免外部讀寫內部型別或資料表。

漸進導入步驟（建議）：
1) 列出目前各模組重複的 SQL/HTTP 呼叫點。
2) 為這些呼叫點定義最小介面（Port），抽出 Repository/Gateway。
3) 將呼叫點改為依賴介面，原本 SQL/HTTP 移至 Adapter 實作。
4) 在組合根綁定正式與測試實作；新增合約測試確保行為一致。
5) 建立變更規則：新增 I/O 一律走 Port；跨模組資料一律經過公開介面或事件。

---

## 目錄建議（功能模組化 + 最小架構）
```
src/
  modules/
    orders/
      domain/            # 內部模型與規則（不含 SQL/HTTP）
      application/       # 用例/服務（依賴介面，不依賴實作）
      interfaces/        # 入站（如 http/grpc handlers）
      infrastructure/    # 出站實作（repo/gateway/cache 等）
    billing/
      ...
  shared/
    kernel/              # 共用型別（時鐘、ID、Result、Bus 介面）
    data/                # 可選：共用 adapters（小心邊界與版本）
  app/
    di/                  # 組合根（相依注入）
    config/
```

---

## 快速檢核（Checklist）
- [ ] 類似的 SQL/HTTP 呼叫已抽象為 Port 與 Repository/Gateway，不再分散於各模組。
- [ ] 模組只依賴介面；具體實作位於 `infrastructure/adapters`，由組合根注入。
- [ ] 跨模組互動只透過公開介面或事件，沒有直接讀寫他模組的內部型別/資料表。
- [ ] 有基本合約測試覆蓋 Ports↔Adapters 的互動；測試可不依賴真實外部系統。
- [ ] 新增 I/O 能力走既有 Port/契約，避免重複實作或灰箱耦合。
